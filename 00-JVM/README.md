### JVM (Java Virtual Machine)
JVM 可以分为5大部分：
* **类加载器（Class Loader）**
  加载字节码文件到内存
* **运行时数据区（Runtime Data Area）**
  JVM核心内存空间的结构模型
  包括方法区、虚拟机栈、本地方法栈、堆、程序计数器
* **执行引擎（Execution Engine）**
  对 JVM 指令进行解析，翻译成机器码，提交给操作系统
* **本地库接口（Native Interface）**
  供 Java 调用的融合了不同开发语言的原始库
* **本地方法库（Native Libraies）**
  Java 本地方法的具体实现
#### 运行时数据区
* **方法区**
  存储加载的类信息、常量、静态变量，方法区是一种规范，永久代是方法区的一种实现，元空间也是方法区的一种实现，Java8 以后用元空间替换永久代（永久代和元空间都是 JVM 内存中的一块区域）
* **本地方法栈**
    * 本地方法：Java 属于基于应用层的高级编程语言，无法访问底层操作系统，就需要使用其他语言来实现，比如 C++
    *  本地方法的使用原理：
        1. 在 Java 程序中声明 native 修饰的方法，只有方法定义，没有方法实现，将 Java 文件编译成字节码文件
        2. 用 javah 命令编字节码文件，生成一个 .h 文件
        3. 编写一个 C++ （.cpp）文件，实现 .h 文件中的方法
        4. 将 .cpp 文件编译成动态链接库文件 .dll
        5. 使用 System.loadLibrary() 加载动态链接库文件 .dll

       常见的本地方法：
       `getClass() //获取运行时类`
       `hashCode() //获取对象的哈希值`
       `wait() //让正在访问当前资源的线程暂停`

* **程序计数器**
  是当前线程执行的字节码（JVM 指令）的行号指示器，JVM 通过改变计数器的值来选取下一条要执行的指令。
  多线程之间的程序计数器互相独立，互不影响，为了保证每个线程恢复执行之后都能回到之前中断的位置，进而继续执行
* **Java 堆**
  每个 Java 对象都会存在堆中，堆被所有线程所共享，是 GC （Garbage Collector 垃圾回收器）的主要管理区域
    * 年轻代：
        * Eden：对象刚被创建的时候，存入 Eden 中
        * Survivor（Survivor From、Survivor To）：
          GC 回收垃圾的时候，将 Eden 中不需要回收（存活）的对象存入 From 中，下一次回收的时候，再将 From 中不需要回收的对象存到 To 中，然后清理 From 区；下一次 GC 开始的时候，将 To 中不需要回收的对象存入 From 中，然后再清理 To 区；依次循环下去...
          每次回收之后，存活下来的对象年龄都会 +1，年龄增加到一定程度后，则会将此对象存入老年代中
    * 老年代：存放年龄比较大的对象
    * 永久代（元空间）：
      JDK1.7及其之前将类的信息存入永久代中；JDK1.8之后使用元空间替换了永久代
      元空间和永久代是方法区的具体实现，方法区只是一种规范
      JDK1.7及其之前字符串常量池存放于永久代中，JDK1.8之后字符串常量池直接存放在堆中（因为永久代空间有限，创建字符串对象时，需要调用 inter 方法；永久代使用的是 JVM 内存，元空间使用的是本地内存，元空间能够存放更多的数据，效率更高）
* **虚拟机栈**
  Java 方法的执行在虚拟机栈中完成，栈中存放的是栈帧，每个栈帧对应着一个被调用的方法，方法的执行其实就是入栈和出栈的过程
  栈帧包括：
    * 局部变量表（Java 方法中用到的局部变量）
    * 操作数栈（数据的入栈出栈）
    * 动态链接（方法的返回地址，方法的出口）

  每执行一个方法，JVM 都会创建一个栈帧，并且将栈帧压入虚拟机栈中，方法执行完毕之后，该栈帧出栈