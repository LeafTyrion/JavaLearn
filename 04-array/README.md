### 数组

数组是一个具有相同数据类型的数据集合，在内存中开辟一串连续的空间，是简单的线性序列，使得对元素的访问变得很快
但代价就是数组对象的大小是固定的，且在该数组的生存周期内不能更改

#### 创建数组

* 声明并初始化内容

  `int[] array = new int[]{1, 2, 3};`

  `int[] array = {1, 2, 3};`

* 声明并指定大小

  `int[] array = new int[3];`

注：创建数组必须指定长度或者初始化内容

#### 数组赋值

* 根据索引（下标）赋值

  `array[0] = 2;`

#### 二维数组

多个一维数组嵌套在一起的数组；一个一维数组中存储的是另一个一维数组，则这个数组是二维数组

#### 创建二维数组

* 声明并初始化二维数组

  `int[][] array = new int[][]{{1, 2, 3}, {1, 2}, {1}};`

  `int[][] array = {{1, 2, 3}, {1, 2}, {1}};`

* 声明并指定二维数组大小

  `int[][] array = new int[3][];`

注：创建二维数据必须先确定外层数组的大小，内存本质其实是：一个一维数组，里面存放着其它一维数组的引用

#### 数组的遍历

```java
for (int i = 0; i < a.length; i++) { //遍历外层数组
	for (int j = 0; j < a[i].length; j++) { //遍历内层数组
    System.out.println(a[i][j]);
  }
}
```

#### 常见问题

1. 数组的下标为什么从0开始？而不是从1开始？

   这样设计的主要原因是为了提高数组的查询效率

   数组在内存空间时连续的，而数组的查询是通过一个寻址公式来完成的，我们拿到的数组实际是数组的首地址（第一个元素的内存地址）

   寻址公式就是通过下标快速计算对应内存地址的一个公式；因为数组的数据类型是一致的，所以数组中的每一块区域长度都一样

   如：`int[] array；`

   `array`记录着第一个元素的内存地址，而每个int占4个byte，则可以计算出第二元素的内存地址为：`第一个元素的内存地址+4byte`；

   则第n个元素内存地址：`第一个元素的内存地址+ (n - 1) *4byte`

   下标从0开始的话，则有寻址公式：`首地址+n*数据类型大小`；少了一步减法运算，提高了查询效率

2. `int[] array = {1, 2, 'a'};`这段代码为什么不报错？

   因为编译器会自动把`'a'`转成对应的ASCII码，`'a'`的ASCII码为97，所以实际存入数组中的值为97

   注：`'A'`的ASCII码为65


